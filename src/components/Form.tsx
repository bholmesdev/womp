// Generated by simple:form

import { navigate } from "astro:transitions/client";
import {
  type ComponentProps,
  createContext,
  useContext,
  useState,
  useRef,
  type FormEvent,
} from "react";
import {
  DropZone,
  FileTrigger,
  type DropZoneProps,
  type FileDropItem,
  type FileTriggerProps,
} from "react-aria-components";
import {
  type FieldErrors,
  type FormState,
  type FormValidator,
  getInitialFormState,
  toSetValidationErrors,
  toTrackAstroSubmitStatus,
  toValidateField,
  validateForm,
  formNameInputProps,
} from "simple:form";

export function useCreateFormContext(
  validator: FormValidator,
  fieldErrors?: FieldErrors,
  formRef?: React.MutableRefObject<HTMLFormElement | null>
) {
  const initial = getInitialFormState({ validator, fieldErrors });
  const [formState, setFormState] = useState<FormState>(initial);
  return {
    value: formState,
    set: setFormState,
    formRef,
    validator,
    setValidationErrors: toSetValidationErrors(setFormState),
    validateField: toValidateField(setFormState),
    trackAstroSubmitStatus: toTrackAstroSubmitStatus(setFormState),
  };
}

export function useFormContext() {
  const formContext = useContext(FormContext);
  if (!formContext) {
    throw new Error(
      "Form context not found. `useFormContext()` should only be called from children of a <Form> component."
    );
  }
  return formContext;
}

type FormContextType = ReturnType<typeof useCreateFormContext>;

const FormContext = createContext<FormContextType | undefined>(undefined);

export function useSubmit(formContext: FormContextType) {
  const handleSubmit = async (formData: FormData, e?: FormEvent) => {
    e?.preventDefault();
    e?.stopPropagation();

    formContext.set((formState) => ({
      ...formState,
      isSubmitPending: true,
      submitStatus: "validating",
    }));

    const parsed = await validateForm({
      formData,
      validator: formContext.validator,
    });
    if (parsed.data) {
      navigate(window.location.href, { formData });
      return formContext.trackAstroSubmitStatus();
    }

    formContext.setValidationErrors(parsed.fieldErrors);
  };

  return handleSubmit;
}

export function Form({
  children,
  validator,
  context,
  fieldErrors,
  name,
  ...formProps
}: {
  validator: FormValidator;
  context?: FormContextType;
  fieldErrors?: FieldErrors;
} & Omit<ComponentProps<"form">, "method" | "onSubmit">) {
  const formRef = useRef<HTMLFormElement>(null);
  const formContext =
    context ?? useCreateFormContext(validator, fieldErrors, formRef);
  const submit = useSubmit(formContext);

  return (
    <FormContext.Provider value={formContext}>
      <form
        {...formProps}
        ref={formRef}
        method="POST"
        onSubmit={(e) => submit(new FormData(e.currentTarget), e)}
      >
        {name ? <input {...formNameInputProps} value={name} /> : null}
        {children}
      </form>
    </FormContext.Provider>
  );
}

export function FileDropSubmit({
  name,
  allowsMultiple,
  ...dropZoneProps
}: DropZoneProps & {
  name: string;
  allowsMultiple?: boolean;
}) {
  const formContext = useFormContext();
  const submit = useSubmit(formContext);
  const fieldState = formContext.value.fields[name];
  if (!fieldState) {
    throw new Error(
      `Input "${name}" not found in form. Did you use the <Form> component?`
    );
  }

  return (
    <DropZone
      getDropOperation={(types) =>
        types.has("audio/mpeg") ? "copy" : "cancel"
      }
      onDrop={async (e) => {
        const items = e.items.filter((file) => file.kind === "file") as
          | FileDropItem[];

        const formData = new FormData(
          formContext.formRef?.current ?? undefined
        );

        if (allowsMultiple) {
          for (const item of items) {
            formData.append(name, await item.getFile());
          }
        } else {
          const file = await items[0]?.getFile();
          file && formData.set(name, file);
        }

        submit(formData);
      }}
      {...dropZoneProps}
    />
  );
}

export function FileTriggerSubmit({
  name,
  ...fileTriggerProps
}: {
  name: string;
} & FileTriggerProps) {
  const formContext = useFormContext();
  const submit = useSubmit(formContext);
  return (
    <FileTrigger
      onSelect={(e) => {
        const files = e ? Array.from(e) : [];
        const formData = new FormData(
          formContext.formRef?.current ?? undefined
        );

        if (fileTriggerProps.allowsMultiple) {
          for (const file of files) {
            formData.append(name, file);
          }
        } else {
          const file = files[0];
          file && formData.set(name, file);
        }

        submit(formData);
      }}
      {...fileTriggerProps}
    />
  );
}

export function Input(inputProps: ComponentProps<"input"> & { name: string }) {
  const formContext = useFormContext();
  const fieldState = formContext.value.fields[inputProps.name];
  if (!fieldState) {
    throw new Error(
      `Input "${inputProps.name}" not found in form. Did you use the <Form> component?`
    );
  }

  const { hasErroredOnce, validationErrors, validator } = fieldState;
  return (
    <>
      <input
        onBlur={async (e) => {
          const value = e.target.value;
          if (value === "") return;
          formContext.validateField(inputProps.name, value, validator);
        }}
        onChange={async (e) => {
          if (!hasErroredOnce) return;
          const value = e.target.value;
          formContext.validateField(inputProps.name, value, validator);
        }}
        {...inputProps}
      />
      {validationErrors?.map((e) => (
        <p key={e}>{e}</p>
      ))}
    </>
  );
}
